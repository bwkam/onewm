@:used
class json2object.reader.BaseParser<T> {

	@:pure(inferredPure)
	function new(errors:Array<json2object.Error>, putils:json2object.PositionUtils, errorType:json2object.ErrorType) {
		this.errors = errors;
		this.putils = putils;
		this.errorType = errorType;
	}

	public var value:json2object.reader.BaseParser.T;

	public var errors:Array<json2object.Error>;

	var errorType:json2object.ErrorType;

	var putils:json2object.PositionUtils;

	@:value({ filename : "" })
	public function fromJson(jsonString:String, filename:String = "") {
		this.putils = new json2object.PositionUtils(jsonString);
		this.errors = [];
		try {
			this.loadJson(new hxjsonast.Parser(jsonString, filename).doParse(), null);
		} catch (`:Dynamic) {
			{
				null;
			};
			var ` = haxe.Exception.caught(`).unwrap();
			if ((Std.isOfType(`, hxjsonast.Error))) {
				var e = cast `;
				this.errors.push(json2object.Error.ParserError(e.message, this.putils.convertPosition(e.pos)));
			} else throw `;
		};
		return this.value;
	}

	@:value({ variable : "" })
	public function loadJson(json:hxjsonast.Json, variable:String = "") {
		var pos = this.putils.convertPosition(json.pos);
		{
			var ` = json.value;
			switch ((@:exhaustive enumIndex `)) {
				case 0: this.loadJsonString(`[0], pos, variable);
				case 1: this.loadJsonNumber(`[0], pos, variable);
				case 2: this.loadJsonObject(`[0], pos, variable);
				case 3: this.loadJsonArray(`[0], pos, variable);
				case 4: this.loadJsonBool(`[0], pos, variable);
				case 5: this.loadJsonNull(pos, variable);
			};
		};
		return this.value;
	}

	function loadJsonNull(pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadJsonString(s:String, pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadString(s:String, pos:json2object.Position, variable:String, validValues:Array<String>, defaultValue:String) {
		if ((validValues.indexOf(s, null) != -1)) return s;
		this.onIncorrectType(pos, variable);
		return defaultValue;
	}

	function loadJsonNumber(f:String, pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadJsonUInt(f:String, pos:json2object.Position, variable:String, value:UInt) {
		var uint = 0;
		f = StringTools.trim(f);
		if ((f.charAt(0) == "-")) f = f.substr(1, null);
		var hex = StringTools.startsWith(f, "0x");
		if ((hex)) f = f.substr(2, null);
		var base = if ((hex)) 16 else 10;
		var pow = 1;
		var i = f.length - 1;
		while ((i >= 0)) {
			var cur = if ((hex)) Std.parseInt("0x" + f.charAt(i)) else Std.parseInt(f.charAt(i));
			if ((cur == null)) {
				this.onIncorrectType(pos, variable);
				return value;
			};
			uint = cast cast uint + pow * cur;
			pow *= base;
			-- i;
		};
		return uint;
	}

	function loadJsonInt(f:String, pos:json2object.Position, variable:String, value:Int) {
		if ((Std.parseInt(f) != null && Std.parseInt(f) == Std.parseFloat(f))) return Std.parseInt(f);
		this.onIncorrectType(pos, variable);
		return value;
	}

	function loadJsonFloat(f:String, pos:json2object.Position, variable:String, value:Float) {
		if ((Std.parseInt(f) != null)) return Std.parseFloat(f);
		this.onIncorrectType(pos, variable);
		return value;
	}

	function loadJsonBool(b:Bool, pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadJsonArray(a:Array<hxjsonast.Json>, pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadJsonArrayValue(a:Array<hxjsonast.Json>, loadJsonFn:haxe.Function, variable:String) {
		var ` = [];
		{
			var `1 = 0;
			while ((`1 < a.length)) {
				var j = a[`1 ++];
				var tmp;
				try {
					tmp = loadJsonFn(j, variable);
				} catch (`:Dynamic) {
					{
						null;
					};
					var ` = haxe.Exception.caught(`).unwrap();
					if ((Std.isOfType(`, json2object.InternalError))) {
						var e = cast `;
						if ((e != json2object.InternalError.ParsingThrow)) throw haxe.Exception.thrown(e);
						continue;
					} else throw `;
				};
				`.push(tmp);
			};
		};
		return `;
	}

	function loadJsonObject(o:Array<hxjsonast.JObjectField>, pos:json2object.Position, variable:String) {
		this.onIncorrectType(pos, variable);
	}

	function loadObjectField(loadJsonFn:haxe.Function, field:hxjsonast.JObjectField, name:String, assigned:Map<String, Bool>, defaultValue:Any, pos:json2object.Position) {
		try {
			var ret = cast loadJsonFn(field.value, field.name);
			assigned.set(name, true);
			return ret;
		} catch (`:Dynamic) {
			{
				null;
			};
			var ` = haxe.Exception.caught(`).unwrap();
			if ((Std.isOfType(`, json2object.InternalError))) {
				var e = cast `;
				if ((e != json2object.InternalError.ParsingThrow)) throw haxe.Exception.thrown(e);
			} else this.errors.push(json2object.Error.CustomFunctionException(`, pos));
		};
		return defaultValue;
	}

	function loadObjectFieldReflect(loadJsonFn:haxe.Function, field:hxjsonast.JObjectField, name:String, assigned:Map<String, Bool>, pos:json2object.Position) {
		try {
			Reflect.setField(this.value, name, cast loadJsonFn(field.value, field.name));
			assigned.set(name, true);
		} catch (`:Dynamic) {
			{
				null;
			};
			var ` = haxe.Exception.caught(`).unwrap();
			if ((Std.isOfType(`, json2object.InternalError))) {
				var e = cast `;
				if ((e != json2object.InternalError.ParsingThrow)) throw haxe.Exception.thrown(e);
			} else this.errors.push(json2object.Error.CustomFunctionException(`, pos));
		};
	}

	function objectSetupAssign(assigned:Map<String, Bool>, keys:Array<String>, values:Array<Bool>) {
		var ` = 0;
		var `1 = keys.length;
		while ((` < `1)) {
			var i = ` ++;
			assigned.set(keys[i], values[i]);
		};
	}

	function objectErrors(assigned:Map<String, Bool>, pos:json2object.Position) {
		var lastPos = this.putils.convertPosition(new hxjsonast.Position(pos.file, pos.max - 1, pos.max - 1));
		{
			var s = assigned.keys();
			while ((s.hasNext())) {
				var s = s.next();
				if ((! assigned.get(s))) this.errors.push(json2object.Error.UninitializedVariable(s, lastPos));
			};
		};
	}

	function onIncorrectType(pos:json2object.Position, variable:String) {
		this.parsingThrow();
	}

	function parsingThrow() {
		if ((this.errorType != cast 0)) throw haxe.Exception.thrown(json2object.InternalError.ParsingThrow);
	}

	function objectThrow(pos:json2object.Position, variable:String) {
		if ((this.errorType == cast 2)) throw haxe.Exception.thrown(json2object.InternalError.ParsingThrow);
		if ((this.errorType == cast 1)) this.errors.push(json2object.Error.UninitializedVariable(variable, pos));
	}

	inline function mapSet(map:Map<String, Bool>, key:String, value:Bool) {
		map.set(key, value);
	}
}